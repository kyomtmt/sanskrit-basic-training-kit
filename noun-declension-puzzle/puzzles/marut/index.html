<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>名詞活用パズル: marut（風）</title>
    <link rel="stylesheet" href="../../common/style.css"> {/* 共通CSSへのパス */}
    <style>
        /* marutパズル専用のスタイルがあればここに記述 */
        .puzzle-board {
            display: flex; /* テーブルとカードエリアを横並びにするため */
            margin-top: 20px;
            flex-wrap: wrap; /* 画面が狭い場合に折り返すように */
        }
        #declension-table-area {
            margin-right: 30px; /* テーブルとカードエリアの間隔 */
            margin-bottom: 20px; /* 画面が狭くて折り返した場合の下マージン */
        }
        #declension-table table {
            border-collapse: collapse; /* テーブルの線を重ねる */
        }
        #declension-table th, #declension-table td {
            border: 1px solid black; /* テーブルの線 */
            padding: 8px;
            min-width: 80px; /* セルの最小幅 */
            height: 35px;    /* セルの高さ */
            text-align: center;
            vertical-align: middle;
            font-size: 0.9em; /* セル内の文字が大きすぎる場合調整 */
        }
        .dropzone {
            background-color: #f0f0f0; /* カードを置ける場所の仮の背景色 */
            /* ↓ セルが空の時に高さが潰れないようにするおまじない */
            min-height: 35px; /* tdのheightと同じかそれ以上 */
            box-sizing: border-box; /* paddingとborderを高さに含める */
        }
        #cards-area {
            border: 2px dashed #ccc;
            padding: 10px;
            width: 280px; /* カードエリアの幅 (カードサイズに合わせて調整) */
            min-height: 300px; /* カードエリアの仮の高さ */
            display: flex; /* カードを横に並べる */
            flex-wrap: wrap; /* カードがエリア幅を超えたら折り返す */
            align-content: flex-start; /* 折り返したカードを上から詰める */
            background-color: #f9f9f9;
        }
        .card {
            border: 1px solid #999;
            background-color: white;
            padding: 5px 10px;
            margin: 4px; /* カード間のマージン */
            cursor: grab; /* ドラッグできることを示すカーソル */
            font-size: 0.95em;
            border-radius: 4px;
            user-select: none; /* ドラッグ中にテキスト選択されるのを防ぐ */
        }
        .controls { /* コントロールエリアのスタイル */
            margin-bottom: 20px;
            text-align: left; /* 左寄せにする場合 */
        }
        .controls button { /* ボタンの共通スタイル */
            padding: 8px 15px;
            margin-left: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>名詞活用パズル: marut（風）</h1>

    <div class="controls">
        <p style="display: inline-block; margin-right: 20px;">スコア: <span id="score">0</span> / 24</p>
        <button id="reset-button">リセット</button>
        <!-- ここに文字種トグルボタンやガイドON/OFFボタンなどを後で追加 -->
    </div>

    <div class="puzzle-board">
        <div id="declension-table-area">
            <p>活用表 (ここにカードをドラッグ＆ドロップ)</p>
            <table id="declension-table">
                <thead>
                    <tr>
                        <th>格</th>
                        <th>単数 (Singular)</th>
                        <th>両数 (Dual)</th>
                        <th>複数 (Plural)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>主格 (Nominative)</td>
                        <td id="cell-nom-sg" class="dropzone"></td>
                        <td id="cell-nom-du" class="dropzone"></td>
                        <td id="cell-nom-pl" class="dropzone"></td>
                    </tr>
                    <tr>
                        <td>対格 (Accusative)</td>
                        <td id="cell-acc-sg" class="dropzone"></td>
                        <td id="cell-acc-du" class="dropzone"></td>
                        <td id="cell-acc-pl" class="dropzone"></td>
                    </tr>
                    <tr>
                        <td>具格 (Instrumental)</td>
                        <td id="cell-ins-sg" class="dropzone"></td>
                        <td id="cell-ins-du" class="dropzone"></td>
                        <td id="cell-ins-pl" class="dropzone"></td>
                    </tr>
                    <tr>
                        <td>与格 (Dative)</td>
                        <td id="cell-dat-sg" class="dropzone"></td>
                        <td id="cell-dat-du" class="dropzone"></td>
                        <td id="cell-dat-pl" class="dropzone"></td>
                    </tr>
                    <tr>
                        <td>奪格 (Ablative)</td>
                        <td id="cell-abl-sg" class="dropzone"></td>
                        <td id="cell-abl-du" class="dropzone"></td>
                        <td id="cell-abl-pl" class="dropzone"></td>
                    </tr>
                    <tr>
                        <td>属格 (Genitive)</td>
                        <td id="cell-gen-sg" class="dropzone"></td>
                        <td id="cell-gen-du" class="dropzone"></td>
                        <td id="cell-gen-pl" class="dropzone"></td>
                    </tr>
                    <tr>
                        <td>処格 (Locative)</td>
                        <td id="cell-loc-sg" class="dropzone"></td>
                        <td id="cell-loc-du" class="dropzone"></td>
                        <td id="cell-loc-pl" class="dropzone"></td>
                    </tr>
                    <tr>
                        <td>呼格 (Vocative)</td>
                        <td id="cell-voc-sg" class="dropzone"></td>
                        <td id="cell-voc-du" class="dropzone"></td>
                        <td id="cell-voc-pl" class="dropzone"></td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div id="cards-area">
            {/* カードはJavaScriptでここに生成します */}
        </div>
    </div>

    <p><a href="../../../index.html">全体メニューに戻る</a></p>

    <script src="../../common/script.js"></script> {/* 共通JSへのパス */}
    <script src="marut-data.js"></script> {/* marut専用データJSへのパス */}
<script>
document.addEventListener('DOMContentLoaded', () => {
    console.log("marut puzzle page loaded");

    const scoreElement = document.getElementById('score');
    const cardsArea = document.getElementById('cards-area');
    const dropzones = document.querySelectorAll('.dropzone');
    const resetButton = document.getElementById('reset-button');
    // const toggleScriptButton = document.getElementById('toggle-script-button'); // 文字種トグルボタンのID（仮）

    let currentScore = 0;
    let totalFillableCells = dropzones.length; // 埋めるべきセルの総数 (24)
    let draggedCardElement = null; // 現在ドラッグ中の「元のカード要素」（カードエリアにあるもの）
    let currentScriptMode = 'romaji'; // 初期表示モード ('romaji' or 'devanagari')

    function updateScoreDisplay() {
        if (scoreElement) {
            scoreElement.textContent = `${currentScore} / ${totalFillableCells}`;
        }
    }

    function initializePuzzle() {
        currentScore = 0;
        draggedCardElement = null;
        if (cardsArea) cardsArea.innerHTML = '';
        dropzones.forEach(zone => {
            zone.innerHTML = '';
        });

        if (typeof marutCardsData !== 'undefined' && marutCardsData.length > 0) {
            console.log("marutCardsData is available:", marutCardsData.length, "definitions");

            // カードエリアに表示するカードは、重複を除いたユニークな形のみで良いか、
            // それとも全24定義分のカードを表示するかで挙動が変わります。
            // 今回は「同じ形のカードを何度も使える」ので、
            // 見た目がユニークなカードリストを作るか、あるいは全活用形を並べるか選択できます。
            // ここでは、簡単のため全活用形をカードエリアに並べる例とします。
            // (もしユニークな形だけにしたい場合は、marutCardsDataを加工する処理が必要)

            const shuffledCards = [...marutCardsData].sort(() => Math.random() - 0.5);

            shuffledCards.forEach(cardData => {
                const cardElement = document.createElement('div');
                cardElement.id = `original-${cardData.id}`; // カードエリアのカードIDは区別
                cardElement.classList.add('card');
                cardElement.draggable = true;
                // 表示するテキストを currentScriptMode に応じて設定
                cardElement.textContent = (currentScriptMode === 'devanagari') ? cardData.devanagari : cardData.romaji;
                // 判定に必要なデータを保持
                cardElement.dataset.romaji = cardData.romaji;
                cardElement.dataset.devanagari = cardData.devanagari;
                // このカードが「どの活用形定義」に対応するかを保持 (オプションだがデバッグに便利)
                cardElement.dataset.originalId = cardData.id;


                cardElement.addEventListener('dragstart', handleDragStart);
                // dragend はカードエリアのカードには不要かも (減らないので)

                if (cardsArea) cardsArea.appendChild(cardElement);
            });
        } else {
            console.error("marutCardsData is NOT available or empty.");
            if (cardsArea) cardsArea.textContent = "カードデータの読み込みに失敗しました。";
        }
        updateScoreDisplay();
    }

    function handleDragStart(event) {
        draggedCardElement = event.target; // ドラッグされた「元の」カード要素を保存
        // dataTransfer には、カードの「テキスト内容」や「どの活用形定義か」の情報を持たせると良い
        const cardText = (currentScriptMode === 'devanagari') ? draggedCardElement.dataset.devanagari : draggedCardElement.dataset.romaji;
        event.dataTransfer.setData('text/plain', cardText);
        event.dataTransfer.setData('application/json', JSON.stringify({
            romaji: draggedCardElement.dataset.romaji,
            devanagari: draggedCardElement.dataset.devanagari
        })); // 両方の情報を持たせる
        console.log('DragStart:', draggedCardElement.id, 'Text:', cardText);
    }

    function handleDragOver(event) {
        event.preventDefault();
    }

    function handleDrop(event) {
        event.preventDefault();
        const targetCell = event.target.closest('.dropzone');
        const droppedCardText = event.dataTransfer.getData('text/plain'); // 表示されていたテキスト
        const cardAllData = JSON.parse(event.dataTransfer.getData('application/json')); // ローマ字・デーヴァ両方

        if (cardAllData && targetCell) {
            console.log('Drop: Text', droppedCardText, 'on cell:', targetCell.id);

            let isCorrectDrop = false;
            // marutCardsDataをループして、targetCell.idにdroppedCardTextが対応するかチェック
            for (const cardDef of marutCardsData) {
                const textInCardDefinition = (currentScriptMode === 'devanagari') ? cardDef.devanagari : cardDef.romaji;
                const romajiInCardDefinition = cardDef.romaji; // 常にローマ字も比較対象として持つ
                const devanagariInCardDefinition = cardDef.devanagari; // 常にデーヴァナーガリーも比較対象として持つ


                if (cardDef.correctCell === targetCell.id &&
                    (romajiInCardDefinition === cardAllData.romaji || devanagariInCardDefinition === cardAllData.devanagari) ) { // ローマ字かデーヴァナーガリーのどちらかが一致すればOK
                    isCorrectDrop = true;
                    break;
                }
            }

            if (isCorrectDrop) {
                if (targetCell.children.length === 0) { // セルが空の場合のみ
                    const newCardElement = document.createElement('div');
                    newCardElement.classList.add('card'); // セル内のカードにもスタイル適用
                    // newCardElement.textContent = droppedCardText; // ドロップされた時のテキストで表示
                    // ↓ 常に両方のデータを持っているので、表示モードに応じて表示内容を変えられる
                    newCardElement.textContent = (currentScriptMode === 'devanagari') ? cardAllData.devanagari : cardAllData.romaji;
                    newCardElement.dataset.romaji = cardAllData.romaji;
                    newCardElement.dataset.devanagari = cardAllData.devanagari;
                    // newCardElement.draggable = false; // 配置後はドラッグ不可にするなど

                    targetCell.appendChild(newCardElement);
                    currentScore++;
                    updateScoreDisplay();
                    console.log('Correct!');

                    if (currentScore === totalFillableCells && totalFillableCells > 0) {
                        setTimeout(() => {
                            alert("素晴らしい！全問正解です！");
                        }, 100);
                    }
                } else {
                    console.log('Cell is already occupied.');
                }
            } else {
                console.log('Incorrect text for this cell.');
            }
        }
        draggedCardElement = null; // ドラッグ操作完了
    }

    dropzones.forEach(zone => {
        zone.addEventListener('dragover', handleDragOver);
        zone.addEventListener('drop', handleDrop);
    });

    if (resetButton) {
        resetButton.addEventListener('click', () => {
            console.log('Reset button clicked');
            initializePuzzle();
        });
    }

    // 文字種トグルボタンの処理 (仮)
    // if (toggleScriptButton) {
    //     toggleScriptButton.addEventListener('click', () => {
    //         currentScriptMode = (currentScriptMode === 'romaji') ? 'devanagari' : 'romaji';
    //         // TODO: カードエリアのカードと、セルに配置済みのカードの表示を更新する処理
    //         // initializePuzzle(); // 簡単なのは再初期化だが、配置済みカードは消える
    //         console.log("Script mode toggled to:", currentScriptMode);
    //         // ここでカードの表示を更新する関数を呼ぶ
    //         updateAllCardDisplays();
    //     });
    // }

    // function updateAllCardDisplays() {
    //     document.querySelectorAll('.card').forEach(cardEl => {
    //         const romaji = cardEl.dataset.romaji;
    //         const devanagari = cardEl.dataset.devanagari;
    //         if (romaji && devanagari) {
    //             cardEl.textContent = (currentScriptMode === 'devanagari') ? devanagari : romaji;
    //         }
    //     });
    // }

    initializePuzzle();
});
    </script>
</body>
</html>
